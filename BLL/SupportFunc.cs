using BLL.DTO;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;

namespace BLL
{
    public static class SupportFunc
    {
        public static string RunFromCmd(string rCodeFilePath, string args)
        {

            var pythonResult = String.Empty;
            var pythonError = String.Empty;

            ProcessStartInfo start = new ProcessStartInfo();
            start.FileName = @"D:\Projects\SV\Python\OracleEtl\venv\Scripts\python.exe";
            start.Arguments = rCodeFilePath + " " + args;
            start.UseShellExecute = false;// Do not use OS shell
            start.CreateNoWindow = true; // We don't need new window
            start.RedirectStandardOutput = true;// Any output, generated by application will be redirected back
            start.RedirectStandardError = true; // Any error in standard output will be redirected back (for example exceptions)

            using (Process process = Process.Start(start))
            {

                pythonResult = process.StandardOutput.ReadToEnd();
                pythonError = process.StandardError.ReadToEnd();
                process.WaitForExit();
            }

            if (!string.IsNullOrEmpty(pythonError))
                return pythonError;

            return pythonResult;

        }


        private static string CorrectAntennaVersionLetterV(string antennaType)
        {
            if (antennaType.Contains("v"))
                return antennaType = antennaType.Replace('v', 'V');

            return antennaType;

        }

        private static string ConcatRruWithBand(string rruType, string band)
        {
            if (band == "900")
                return rruType + "-9";
            else if (band == "1800")
                return rruType + "-18";
            else if (band == "2100")
                return rruType + "-21";
            else if (band == "2600")
                return rruType + "-26";

            return string.Empty;
        }

        public static List<ViewModelTechnology> MapAssetTechWithCmTech(List<ViewModelTechnology> assetTechnologies, IEnumerable<string> cellNamesFromCM)
        {
            var cellNamesForClean = assetTechnologies.Select(n => n.CellName).Intersect(cellNamesFromCM);
            var cleanedTechs = new List<ViewModelTechnology>();

            foreach (var cellName in cellNamesForClean)
            {

                var assetTechs = assetTechnologies.Where(n => n.CellName == cellName);

                foreach (var assetTech in assetTechs)
                {
                    if (assetTech != null)
                        cleanedTechs.Add(assetTech);
                }
            }
            return cleanedTechs;
        }

        public static Dictionary<string, double> InitialPowerCalc(string pathFileTxt)
        {
            var stringFile = pathFileTxt;
            string[] arrLine = stringFile.Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);
            var resultDict = new Dictionary<string, double>();

            for (int i = 1; i < arrLine.Length; i++)
            {
                var parts = arrLine[i].Split('|').ToList();
                parts.RemoveAt(parts.Count - 1);
                var stringPart = String.Join(" ", parts);
                double decimalPart;
                try
                {
                    decimalPart = double.Parse(arrLine[i].Split('|').Last());
                }
                catch
                {
                    throw new ArgumentException("В регионалните сетинги разделителя трябва да бъре точка");
                }

                if (!resultDict.ContainsKey(stringPart))
                    resultDict.Add(stringPart, decimalPart);
            }
            return resultDict;
        }

        public static List<ModelRRU> GetMapPower()
        {
            var input = Properties.Resources.MapPower_TRX_BAND_RRU
                .Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries)
                .Skip(1);
            var lstMap = new List<ModelRRU>();

            foreach (var row in input)
            {
                var map = new ModelRRU();
                var rowElements = row.Split('|');
                for (int i = 0; i < rowElements.Length; i++)
                    if (rowElements[i] == "")
                        rowElements[i] = "0";

                //Ако мощностите и на трите технологии заедно са равни на 0 да не се пълнят в списъка
                if (rowElements.Skip(5).First() == "0" && rowElements.Skip(6).First() == "0" && rowElements.Skip(7).First() == "0")
                    continue;

                map.RRU_Type = rowElements.First();
                map.Band = rowElements.Skip(1).First();
                map.GSM_TRX = int.Parse(rowElements.Skip(2).FirstOrDefault());
                map.UMTS_TRX = int.Parse(rowElements.Skip(3).FirstOrDefault());
                map.LTE_TRX = int.Parse(rowElements.Skip(4).FirstOrDefault());
                map.GSM_Pwr_per_TRX = rowElements.Skip(5).First();
                map.UMTS_Pwr_per_TRX = rowElements.Skip(6).First();
                map.LTE_Pwr_per_TRX = rowElements.Skip(7).First();

                map.NR_Pwr_per_TRX = "0";

                lstMap.Add(map);
            }
            return lstMap;
        }

        public static double GetPortCalcPower(string modelRRU, int GSM_TRX, int UMTS_TRX, int LTE_TRX, int NR_TRX)
        {

            modelRRU = modelRRU.Replace("AC", "");
            modelRRU = modelRRU.Replace("DB", "");

            if (LTE_TRX > 1)
                LTE_TRX = 1;

            var getMapPower = GetMapPower();

            var mapingInW = getMapPower.Select(n => new
            {
                RRU_Type = n.RRU_Type,
                Band = n.Band.ToString(),

                GSM_TRX = n.GSM_TRX,
                //Watt
                GSM_Pwr_per_TRX = double.Parse(n.GSM_Pwr_per_TRX),

                UMTS_TRX = n.UMTS_TRX,
                //Watt
                UMTS_Pwr_per_TRX = double.Parse(n.UMTS_Pwr_per_TRX),

                LTE_TRX = n.LTE_TRX,
                //Watt
                LTE_Pwr_per_TRX = double.Parse(n.LTE_Pwr_per_TRX),

                NR_TRX = n.NR_TRX,
                //Watt
                NR_Pwr_per_TRX = double.Parse(n.NR_Pwr_per_TRX),

            });

            double powerInW = 0;


            foreach (var map in mapingInW)
            {
                //if (map.RRU_Type == modelRRU && GSM_TRX == map.GSM_TRX && UMTS_TRX == map.UMTS_TRX && LTE_TRX == map.LTE_TRX)
                //{
                //    powerInW = (map.GSM_TRX * map.GSM_Pwr_per_TRX) + (map.UMTS_TRX * map.UMTS_Pwr_per_TRX) + (map.LTE_Pwr_per_TRX * map.LTE_TRX);

                //    //16.03.2017 Power Correction for SA/SRF
                //    //powerInW = map.GSM_Pwr_per_TRX + map.UMTS_Pwr_per_TRX + map.LTE_Pwr_per_TRX;
                //    break;
                //}
                if (map.RRU_Type == modelRRU && GSM_TRX == map.GSM_TRX && UMTS_TRX == map.UMTS_TRX 
                    && LTE_TRX == map.LTE_TRX && NR_TRX == map.NR_TRX)
                {
                    powerInW = (map.GSM_TRX * map.GSM_Pwr_per_TRX) + (map.UMTS_TRX * map.UMTS_Pwr_per_TRX) + (map.LTE_Pwr_per_TRX * map.LTE_TRX) + (map.NR_Pwr_per_TRX * map.NR_TRX);

                    //16.03.2017 Power Correction for SA/SRF
                    //powerInW = map.GSM_Pwr_per_TRX + map.UMTS_Pwr_per_TRX + map.LTE_Pwr_per_TRX;
                    break;
                }
            }

            return powerInW;
        }

        //New 15.03.2017
        public static double GetPortCalcPowerIRFC(ModelRRU rru)
        {
            if (rru == null)
                return 0;
                                 
            return (rru.GSM_TRX * ConvertdBm_W(double.Parse(rru.GSM_Pwr_per_TRX))) +
                    (rru.UMTS_TRX * ConvertdBm_W(double.Parse(rru.UMTS_Pwr_per_TRX))) +
                    (rru.LTE_TRX * ConvertdBm_W(double.Parse(rru.LTE_Pwr_per_TRX))) +
                    (rru.NR_TRX * ConvertdBm_W(double.Parse(rru.NR_Pwr_per_TRX)));

        }

        public static double ConvertW_dBm(double w)
        {
            return 10 * Math.Log10(1000 * w);
        }

        public static double ConvertdBm_W(double dBm)
        {
            return Math.Pow(10, (dBm - 30) / 10);
        }


        //OLD!!!!! not used any more
        //Info! Dictionary<int,string[]>   Key: 1 Band position in Excel Value[]:Band[0] "790-960" [1] "Free"
        public static Dictionary<int, string[]> GetAntennaPortMapping(string antennaType)
        {

            antennaType = CorrectAntennaVersionLetterV(antennaType);

            // var path = $@"{Directory.GetCurrentDirectory()}\AntennaPortMapping.txt";
            var path = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "AntennaPortMapping.txt");

            var inputFile = File.ReadAllText(path).Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);

            var mapper = new Dictionary<int, string[]>();

            foreach (var item in inputFile)
            {
                if (item.Contains(antennaType))
                {
                    var band = item.Split('|').Skip(1).Select(n => n.Trim()).ToList();
                    for (int i = 0; i < band.Count; i++)
                        mapper.Add(i + 1, new string[] { band[i], "Free" });

                    return mapper;
                }
            }



            throw new Exception($"Антената {antennaType} не може да бъде намерена във входния файл с антените!");

        }

        public static bool IsEqualBand(string portBandRange, string portBand)
        {
            var lowFreq = int.Parse(portBandRange.Split('-').First().Trim());
            var hiFreq = int.Parse(portBandRange.Split('-').Last().Trim());
            var intPortBand = int.Parse(portBand);
            if (intPortBand >= lowFreq && intPortBand <= hiFreq)
                return true;

            return false;
        }

        //Проверява дали дадено пропърти има атрибут
        public static bool HasAttribute(Type attributeType, PropertyInfo prop)
        {

            var custAttribType = prop.CustomAttributes.ToList();
            if (custAttribType.Count() > 0)
            {
                if (custAttribType.Any(n => n.AttributeType.Name == attributeType.Name))
                {
                    return true;
                }
                else
                    return false;
            }
            return false;
        }

        public static void CheckForCorrectSiteName(string siteID)
        {
            if (string.IsNullOrEmpty(siteID) || !Regex.IsMatch(siteID, "^[A-Z]{2}[\\d]{4}$"))
            {
                throw new ArgumentException("Моля въведете правилно SiteID. Пример: SF1001");
            }
        }

        public static string ShowErrorMetodAndMsg(Exception ex, List<string> lstAssemblyName)
        {
            var s = new StackTrace(ex);
            var frame = s.GetFrames();
            var lstAssemblies = new List<Assembly>();

            var test = AppDomain.CurrentDomain.GetAssemblies();

            foreach (var assemblyName in lstAssemblyName)
            {
                var assembly = AppDomain.CurrentDomain.GetAssemblies().SingleOrDefault(assem => assem.GetName().Name == assemblyName);
                lstAssemblies.Add(assembly);
            }

            foreach (var thisasm in lstAssemblies)
            {
                if (thisasm == null)
                    continue;

                var methodnames = frame.Select(f => f.GetMethod());

                foreach (var methodname in methodnames)
                {
                    if (methodname.Module.Assembly == thisasm)
                        return String.Format($"Грешка в метод {methodname.Name} :{Environment.NewLine}{ex.Message}");
                }

            }

            return String.Empty;
        }

        public static string MapCmRruWithDropDownRru(List<ModelRRU> modelRRUs)
        {
            var rruSingleBand = new string[]
            {
                "3926","3804","3826","3911В","3911E","3826-UPA" ,"3826-KKQ"
            };

            var rrusContainABCD = false;

            if (modelRRUs.Any(n => n.RRU_Type.Contains("AB") ||
                n.RRU_Type.Contains("CD") || n.RRU_Type.Contains("DB") || n.RRU_Type.Contains("AC")))
                rrusContainABCD = true;

            modelRRUs.RemoveAll(n => n.RRU_Type.Contains("REUSE"));

            foreach (var rru in modelRRUs)
            {
                if (string.IsNullOrEmpty(rru.RRU_Type) || string.IsNullOrEmpty(rru.Band) || string.IsNullOrEmpty(rru.RRU_SN))
                    return string.Empty;

                if (!rruSingleBand.Any(n => n == rru.RRU_Type) && !rrusContainABCD)
                    rru.RRU_Type = ConcatRruWithBand(rru.RRU_Type, rru.Band);
            }

            var groupByRru_SN = modelRRUs.GroupBy(n => n.RRU_SN)
                       .Select(n => new
                       {
                           RRU_Type = n.Select(k => k.RRU_Type).FirstOrDefault(),
                       }).ToList();

            if (groupByRru_SN.Count == 1) //Catch 3926 or 3936-9
                return modelRRUs.First().RRU_Type;
            else if (rrusContainABCD)
                return string.Join(" ", groupByRru_SN.Select(n => n.RRU_Type).Distinct());
            else
            {
                var uniqueRruType = groupByRru_SN.Select(n => n.RRU_Type).Distinct().Count();


                if (groupByRru_SN.Count() == 2 && uniqueRruType == 1) //Catch 2х3804
                    return "2x" + groupByRru_SN.First().RRU_Type;
                else if (groupByRru_SN.Count() == 2 && uniqueRruType == 2)  //Catch 3953-18 3953_21
                    return string.Join(" ", groupByRru_SN.Select(n => n.RRU_Type));
                else if (groupByRru_SN.Count() == 3)    //Catch 3953-18-2х3826
                {
                    var groupByRruType = groupByRru_SN.GroupBy(n => n.RRU_Type)
                        .Select(n => new Port
                        {
                            RRU_Type = n.Key,
                            RRU_Total = n.Count().ToString()
                        }).ToList();

                    foreach (var rru in groupByRruType)
                        if (rru.RRU_Total == "2")
                            rru.RRU_Type = "2x" + rru.RRU_Type;

                    return string.Join(" ", groupByRruType.Select(n => n.RRU_Type));

                }

            }

            return string.Empty;
        }

        public static string FeederTypeMap(string feederType)
        {
            var dic = new Dictionary<string, string>()
            {
               {"2xLDF4-50A (1800MHz)" , "1/2" },
               {"2xLDF5-50A (1800MHz)" , "7/8" },
               {"LDF4-50A (1800MHz)" , "1/2" },
               {"LDF4-50A (2000MHz)" , "1/2" },
               {"LDF4-50A (2000MHz,Tr)" , "1/2" },
               {"LDF4-50A (960MHz)" , "1/2" },
               {"LDF4-50A (2600MHz)" , "1/2" },
               {"LDF5-50A (1800MHz)" , "7/8" },
               {"LDF5-50A (2000MHz)" , "7/8" },
               {"LDF5-50A (2000MHz,Tr)" , "7/8" },
               {"LDF5-50A (960MHz)" , "7/8" },
               {"LDF5-50A (2600MHz)" , "7/8" },
               {"LDF6-50A (1700MHz)" , "5/4" },
               {"LDF6-50A (2000MHz)" , "5/4" },
               {"LDF6-50A (2000MHz,Tr)" , "5/4" },
               {"LDF6-50A (960MHz)" , "5/4" },
               {"LDF6-50A (2600MHz)" , "5/4" },
               { "RRU TOP JUMPER (1800MHz)" , "RRU TOP JUMPER" },
               { "RRU TOP JUMPER (2000MHz)" , "RRU TOP JUMPER" },
               { "RRU TOP JUMPER (900MHz)" , "RRU TOP JUMPER" },
               { "RRU TOP JUMPER (2600MHz)" , "RRU TOP JUMPER" },
            };

            if (dic.ContainsKey(feederType))
                return dic[feederType];
            else
                return "Unknown";

        }
    }
}
